****************************** 1. Что такое "коллекция".

Коллекциями/контейнерами в Java принято называть классы, основная цель которых – хранить набор других элементов.
Коллекции могут хранить любые ссылочные типы данных.Позволяет хранить любые данные, включая null в качестве элемента.

****************************** 1.1. Перечислите основные методы из интерфейса java.util.Collection.

add() добавляет указанный элемент
size() количество элементов в этой коллекции.
equals() Сравнивает указанный объект с этой коллекцией для равенства.
sort() сортировка в алфавитном порядке, по у умоолчанию.
reverse() перевернуть список.
min(), max() найти следующие элементы.
iterator() Возвращает итератор по элементам в этой коллекции
hashCode() Возвращает значение хэш-кода для этой коллекции.

****************************** 2. Назовите преимущества использования коллекций.
отсутствует необходимость следить за размерами коллекции (в отличае от массива)
в коллекциях реализовано много методов по добавлению, удалению, сортировке, которые позволяют сократить
количество кода и требуют меньше усилий для реалезации
если правильно подобрать коллекцию то можно увеличить производительность программы.

***************************** 4.Какие есть типы коллекций? Как они характеризуются?

Set - Множество. (Здесь могут храниться только уникальные значения, нет дубликатов)
Queue (Deque) - Очередь. FIFO (Первый вошел, первый вышел). реализуется LinkedList'ом
List - Упорядоченное хранение данных. (В какой последовательности данные положили, в такой они и хранятся)
Map - (от Collection он не наследуется) Значения хранятся как пара - ключ-значение.
и по ключу получаем значение. у мапы нету итератора.

**************************** 5. Назовите основные реализации List, Set, Map.

1List!!!
Класс ARRAYLIST построен на базе массива. Это означает, что доступ по индексу (порядковому номеру элемента) происходит очень быстро.
А добавление элементов в середину списка в общем случае довольно затратно, т.к. нужно будет подвинуть вправо каждый элемент,
который идёт после добавляемого. С удалением такая же штука. Кроме того, массив, лежащий в основе этой структуры данных,
имеет конечное количество свободных ячеек и если их перестанет хватать, придётся создать новый массив большего размера,
перенеся в него все элементы из исходного. Но всё это скрыто внутри реализации ArrayList.

Класс LINKEDLIST представляет собой цепочку элементов, в которой каждый элемент имеет ссылку на предыдущий элемент и на следующий.
Также имеется ссылка на начало и на конец списка, что позволяет быстро получать доступ к первому и к последнему элементу.
При этом для доступа по индексу требуется пройтись последовательно по всей цепочке, поэтому время доступа по индексу прямо
пропорционально размеру списка. Однако сам процесс добавления и удаления элементов весьма прост: нужно всего лишь изменить пару ссылок.
vector и stack
----------------------------------------------------------------------------------------------------------------------------------------
2SET!!!
HashSet
Первая из них - классы реализующие этот интерфейс не могут содержать дубликаты элементов. Их также называют множества.
Замена элемента. Коллекции java.util.Set не поддерживают замену элементов, потому что нет возможности явно указать ячейку.
Это связано с внутренней реализацией коллекций типа java.util.Set.

LinkedHashSet
Следующая реализация - это LinkedHashSet, которая расширяет предыдущую. Основное различие заключается в том,
что при обходе элементов мы будем видеть их в порядке добавления

TreeSet
имеет в своей основе структуру данных «красно-чёрное дерево», что позволяет сортировать элементы автоматически.
----------------------------------------------------------------------------------------------------------------------------------------
3.Словарь (map)

Интерфейс Map представляет собой набор из пар элементов типа «ключ-значение».Словарь гарантирует, что каждому ключу соответствует одно и только одно значение.
Если по уже существующему ключу положить новое значение, то оно перезатрёт старое. При работе с ключами также используются методы equals и hashCode.

HashMap!!!
Первая реализация - это HashMap, которая не гарантирует никакого порядка элементов при обходе. Обратите внимание,
что при повторном добавлении элемента с тем же ключом, мы теряем первое значение.

LinkedHashMap!!
Ещё одна реализация - это LinkedHashMap, которая сохраняет порядок добавления.

 TreeMap!!!
Ну и третья популярная реализация интерфейса Map - это TreeMap, которая сортирует ключи по порядку.

******************************** 6. В чём отличие ArrayList от LinkedList?

ArrayList разрешает произвольный доступ к элементам в списке.	LinkedList не разрешает произвольный доступ к элементам в списке.
Внутренняя структура, используемая для хранения элементов, - это динамический массив.	Внутренняя структура,
используемая для хранения элементов, представляет собой список с двумя ссылками.
Манипуляции с элементами в списке в ArrayList выполняются медленнее.	В LinkedList обработка элементов в списке выполняется быстрее.
ArraylList ведет себя как List, поскольку он реализует список.	        LinkedList ведет себя как List, а также как Queue, поскольку он реализует как List, так и Queue.

******************************* 7. В чём отличие HashSet от TreeSet?

Начнем с того, что Set — это множество (так же называют «набором»). Set не допускает хранение двух одинаковых элементов.
Формально говоря, термин «множество» и так обозначает совокупность различных элементов, очень важно, что именно различных элементов,
так как это главное свойство Set. С учетом такого определения, пояснение про хранение одинаковых элементом не требуется, но в обиходе,
 понятие «множество» потеряло свой строгий смысл касательно уникальности элементов, входящих в него, поэтому все же уточняйте отдельно
  данное свойство множества.

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций в TreeSet lg N.
HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet в качестве ключа выступает сам элемент,
кроме того HashSet (как и HashMap) не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

******************************** 8. В чём отличие Set от Map?

******************************** 9.Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?
Порядок задается либо естественным следованием элементов (Natural order), либо объектом, реализующим интерфейс сравнения Comparator.
Если объекты коллекции поддерживают интерфейс Comparable, то через Collections.sort(collection);
Если нет, то у коллекции вызвать метод sort и передать ему Comparator в качестве аргумента. через Comparable или Comparator.

******************************** 10. Чем отличается Comparable от Comparator?

Comparable - придает объектам какого то класса сравнимость (у каждого объекта есть метод compareTo,
в который можно передать другой объект для сравнения). Collections.sort(collection);
Comparator - треться сторона для сравнения (пишется отдельно и сравнивает два объекта данных ему.) collection.sort(new Comparator{});

******************************** 11.Что такое сортировка по принципу Natural Order?

Некоторые классы из коробки реализуют естественный порядок для сортировки.
Это строки - лексикографический (по алфавиту),
числа - числовой, знаковый или без (больше меньше),
дата - хронологичский (по датам),
файл - лексикографический по имени пути
boolean - false < true
Остальные классы нужно руками делать Comparable или Comparator.

******************************* 12. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. hashcode возвращает число,
являющееся уникальным идентификатором объекта. Это алгоритм, который позволяет множество значений объектов сузить до какого-то натурального количества.
equals сравнивает объекты по значению их полей. Объекты всех коллекций в названии которых есть Hash... должны иметь hashcode и equals.

******************************* 13.Какие есть способы перебора всех элементов List?

через index (fori, while)
через iterator (while)
foreach

******************************** 14. Как реализован цикл foreach?

Через iterator (Если коллекция экстендится от iterable, то мы можем перебирать элементы этой коллекции форичем)

******************************** 15. В чем разница между Iterator и Iterable?

An Iterable - Это простое представление ряда элементов, которые можно перебирать. Он не имеет состояния итерации, такого как "текущий элемент". Вместо этого, он имеет один метод, который производит Iterator.
An Iterator - объект с состоянием итерации. Он позволяет проверить, есть ли у него больше элементов, используя hasNext() и перейти к следующему элементу (если есть) с помощью next().
как правило,Iterable должен быть в состоянии произвести любое количество действующих Iterators.

******************************** 16. Как происходит удаление элементов из ArrayList?

Перекидывание элемента в конец массива путем смещения всех последующих элементов, а затем уменьшение поля size на 1

******************************* 17. Как происходит удаление элементов из LinkedList?


